import sys
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Pt
class summary:

    def __init__(self,  cusTable, settings):

        # Getting The Title for This Section
        allKeys = list(cusTable.keys())
        if "title" in allKeys:
            self.title = cusTable['title']
        else:
            self.title  = settings['summary']['title']

        # Use Previous Results for This Section
        if "usePrevResults" in allKeys:
            self.usePrevResults = cusTable['usePrevResults']
        else:
            self.usePrevResults = settings['summary']['usePrevResults']

        # System Prompts are Added (NOT REPLACED)!
        if "systemPrompts" in allKeys:
            self.systemPrompts = cusTable['systemPrompts'] + settings['summary']['systemPrompts']
        else:
            self.systemPrompts = settings['summary']['systemPrompts']
        # User Prompts are Added (NOT REPLACED)!
        if "userPrompts" in allKeys:
            self.userPrompts = cusTable['userPrompts'] + settings['summary']['userPrompts']
        else:
            self.userPrompts = settings['summary']['userPrompts']

        self.settings = settings
        self.gptModel = settings["openAI"]["model"]
        self.apiPrompt = []
        self.chatGPTResponse = ""

    # Generating The Text Prompt for The Table!
    def generateSummaryPrompts(self, generationBlocks):

        # Setting Up The System Prompt!
        systemPrompt = ""

        # Getting The Previous Outputs!!!
        if self.usePrevResults:
            if not generationBlocks == []:
                systemPrompt = "Previous Conversation Information: \n \n"
                for block in generationBlocks:
                    # Getting The Title!!!
                    systemPrompt = systemPrompt + block.getTitle() + "\n"
                    # Getting The chatGPT Response!!!
                    systemPrompt = systemPrompt + block.getChatGPTResponse() + "\n"

        if self.usePrevResults:
            if not generationBlocks == []:
                systemPrompt = systemPrompt + "\n New Information: \n"

        for prompt in self.systemPrompts:
            systemPrompt = systemPrompt + prompt + " \n "

        # Getting The Target Company Details!
        systemPrompt = systemPrompt + " \n Target Company: \n"
        for key in self.settings['target']:
            systemPrompt = systemPrompt + key + ": " + self.settings['target'][key] + "\n"



        # Getting The Report Generator Company!
        systemPrompt = systemPrompt + " \n Report Generated by Company: \n"
        for key in self.settings['generator']:
            systemPrompt = systemPrompt + key + ": " + self.settings['generator'][key] + "\n"
        systemPrompt = systemPrompt + " \n "

        # Providing The Different Parameter Information!
        systemPrompt = systemPrompt + " \n Different Parameters and Definitions used in the Analysis: \n"
        for paramKey in self.settings['tableInfo'].keys():
            if paramKey == "prompt":
                continue
            else:
                systemPrompt = systemPrompt + paramKey + ":" + self.settings['tableInfo'][paramKey] + "\n"
        systemPrompt = systemPrompt + " \n "

        # Generating The User Prompt
        userPrompt = ""
        for line in self.userPrompts:
            userPrompt = userPrompt + line + "\n"

        apiMessage = [
            {"role": "system", "content": systemPrompt},
            {"role": "user", "content": userPrompt},
        ]
        self.apiPrompt = apiMessage
        return apiMessage

    def summarizeGPT(self, client):

        if self.apiPrompt == []:
            print("The System Prompt for CHAT-GPT is Empty, Section: Summary")
            print("CHECK summarizeGPT function of Summary")
            print("Program Terminating!!!")
            sys.exit()


        chat_completion = client.chat.completions.create(messages=self.apiPrompt, model=self.gptModel)
        self.chatGPTResponse = chat_completion.choices[0].message.content
        print("Summary Section Completed with the following summary ", self.chatGPTResponse)
        return self.chatGPTResponse

    def getTitle(self):
        return self.title

    def getChatGPTResponse(self):
        return self.chatGPTResponse

    def generateReport(self, document):

        document.add_heading(self.title)

        # Writing The Paragraphs
        splitParas = self.chatGPTResponse.split("\n")

        for para in splitParas:
            paragraph = document.add_paragraph(para)
            paragraph.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY


        document.add_page_break()

class introduction:

    def __init__(self,  cusTable, settings):

        # Getting The Title for This Section
        allKeys = list(cusTable.keys())
        if "title" in allKeys:
            self.title = cusTable['title']
        else:
            self.title  = settings['intro']['title']

        # Use Previous Results for This Section
        if "usePrevResults" in allKeys:
            self.usePrevResults = cusTable['usePrevResults']
        else:
            self.usePrevResults = settings['intro']['usePrevResults']

        # System Prompts are Added (NOT REPLACED)!
        if "systemPrompts" in allKeys:
            self.systemPrompts = cusTable['systemPrompts'] + settings['intro']['systemPrompts']
        else:
            self.systemPrompts = settings['intro']['systemPrompts']
        # User Prompts are Added (NOT REPLACED)!
        if "userPrompts" in allKeys:
            self.userPrompts = cusTable['userPrompts'] + settings['intro']['userPrompts']
        else:
            self.userPrompts = settings['intro']['userPrompts']

        self.settings = settings
        self.gptModel = settings["openAI"]["model"]
        self.apiPrompt = []
        self.chatGPTResponse = ""

    # Generating The Text Prompt for The Table!
    def generateIntroPrompts(self, generationBlocks):

        # Setting Up The System Prompt!
        systemPrompt = ""

        # Getting The Previous Outputs!!!
        if self.usePrevResults:
            if not generationBlocks == []:
                systemPrompt = "Previous Conversation Information: \n \n"
                for block in generationBlocks:
                    # Getting The Title!!!
                    systemPrompt = systemPrompt + block.getTitle() + "\n"
                    # Getting The chatGPT Response!!!
                    systemPrompt = systemPrompt + block.getChatGPTResponse() + "\n"

        if self.usePrevResults:
            if not generationBlocks == []:
                systemPrompt = systemPrompt + "\n New Information: \n"

        for prompt in self.systemPrompts:
            systemPrompt = systemPrompt + prompt + " \n "

        # Getting The Target Company Details!
        systemPrompt = systemPrompt + " \n Target Company: \n"
        for key in self.settings['target']:
            systemPrompt = systemPrompt + key + ": " + self.settings['target'][key] + "\n"



        # Getting The Report Generator Company!
        systemPrompt = systemPrompt + " \n Report Generated by Company: \n"
        for key in self.settings['generator']:
            systemPrompt = systemPrompt + key + ": " + self.settings['generator'][key] + "\n"
        systemPrompt = systemPrompt + " \n "

        # Providing The Different Parameter Information!
        systemPrompt = systemPrompt + " \n Different Parameters and Definitions used in the Analysis: \n"
        for paramKey in self.settings['tableInfo'].keys():
            if paramKey == "prompt":
                continue
            else:
                systemPrompt = systemPrompt + paramKey + ":" + self.settings['tableInfo'][paramKey] + "\n"
        systemPrompt = systemPrompt + " \n "

        # Generating The User Prompt
        userPrompt = ""
        for line in self.userPrompts:
            userPrompt = userPrompt + line + "\n"

        apiMessage = [
            {"role": "system", "content": systemPrompt},
            {"role": "user", "content": userPrompt},
        ]
        self.apiPrompt = apiMessage
        return apiMessage

    def introGPT(self, client):

        if self.apiPrompt == []:
            print("The System Prompt for CHAT-GPT is Empty, Section: Introduction")
            print("CHECK summarizeGPT function of Introduction")
            print("Program Terminating!!!")
            sys.exit()


        chat_completion = client.chat.completions.create(messages=self.apiPrompt, model=self.gptModel)
        self.chatGPTResponse = chat_completion.choices[0].message.content
        print("Introduction  Section Completed with the following Introduction ", self.chatGPTResponse)
        return self.chatGPTResponse

    def getTitle(self):
        return self.title

    def getChatGPTResponse(self):
        return self.chatGPTResponse

    def generateReport(self, document):

        document.add_heading(self.title)

        # Writing The Paragraphs
        splitParas = self.chatGPTResponse.split("\n")

        for para in splitParas:
            paragraph = document.add_paragraph(para)
            paragraph.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY


        document.add_page_break()



class methodology:

    def __init__(self, settings):
        self.settings = settings

    def generateReport(self, document):

        document.add_heading("Methodology")

        # Getting the Methodology Text!
        for paraArray in self.settings['methodology']:
            paragraph = ""
            for sentence in self.settings['methodology'][paraArray]:
                paragraph = paragraph + sentence

            paragraph = document.add_paragraph(paragraph)
            paragraph.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY


class References:

    def __init__(self, cusTable, settings):
        # Getting Customized [Table Reporting] Block Settings!
        allKeys = list(cusTable.keys())

        # Excel File Selection
        if "excel" in allKeys:
            self.excel = cusTable['excel']
        else:
            self.excel = settings['references']['excel']

        # SHEET Selection
        if "sheet" in allKeys:
            self.sheet = cusTable['sheet']
        else:
            self.sheet = settings['references']['sheet']

        # Table Columns Selection:
        if "column" in allKeys:
            self.columns = cusTable['columns']
        else:
            self.columns = settings['references']['columns']

        if "title" in allKeys:
            self.title = cusTable['title']
        else:
            self.title = settings['references']['title']

        self.settings = settings

        # This function should return selected requested Columns of the Table!

    def requestingTable(self, excelManager, columns):
        table = excelManager.requestSheet(self.excel, self.sheet)
        # CHECK IF THE TABLE HAS ALL OF THE REQUIRED COLUMNS!!!
        for reqColumn in columns:
            found = False
            for col in table.columns:
                if col == reqColumn:
                    found = True
                    continue
            if not found:
                print("Some Columns Missing in the Table")
                print(f" This column:{reqColumn} is missing from the table")
                print("Program Terminating")
                sys.exit()

        # returning The Requested Table Columns!
        return table[columns]

    def generateReport(self, document, excelManager):

        table = self.requestingTable(excelManager, self.columns)

        if self.title == "":
            pass
        else:
            titlePara = document.add_paragraph(None)
            title = titlePara.add_run(self.title)
            title.bold = True
            title.font.size = Pt(12)

        for i in range(len(table.index)):
            chemicalName = table[self.columns[0]].iloc[i]
            reference = table[self.columns[1]].iloc[i]
            para = document.add_paragraph(None, style='List Number')
            chemName = para.add_run(chemicalName + ':  ')
            chemName.bold = True
            chemName.font.size = Pt(11)
            ref = para.add_run(reference)
            ref.font.size = Pt(9)